## T4: 最短哈密顿路径



$f_{i,j}$是$0 \rightarrow j$ 经过点的状态为$i$的最短路径

$i$ 中第$k$位为1则经过，实现时枚举所有$i$($i<(1<<n)$)
$$
f_{i,j}=\mathop{min}_{0\le k<n}\{ f_{i-(1<<j),k}+w_{k,j},f_{i,j} \}
$$
类似Floyd使用点$k$对$f_{i,j}$进行松弛：**当$i$的状态包含到达$j$和$k$时**，遍所有从到达$k$且没有经过$j$的点出发到$j$

```c++
	f[1][0] = 0;
	for (int i = 1; i < (1 << n); i++)
	{
		for (int j = 0; j < n; j++)
		{
			if ((i >> j) & 1)
			{
				for (int k = 0; k < n; k++)
				{
					if (k != j && ((i >> k) & 1))
					{
						f[i][j] = min(f[i - (1 << j)][k] + w[k][j], f[i][j]);
					}
				}
			}
		}
	}
```



