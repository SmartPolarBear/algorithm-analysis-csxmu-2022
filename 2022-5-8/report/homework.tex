\documentclass[a4paper,twoside]{article}
\usepackage{blindtext}  
\usepackage{geometry}

% Chinese support
\usepackage[UTF8, scheme = plain]{ctex}

% Page margin layout
\geometry{left=2.3cm,right=2cm,top=2.5cm,bottom=2.0cm}


\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{float}
\usepackage{hyperref}

\usepackage{graphics}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{epsfig}
\usepackage{float}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{longtable}
\usepackage{listings}
\usepackage{tikz}
\usepackage{multicol}

% cite package, to clean up citations in the main text. Do not remove.
\usepackage{cite}

\usepackage{color,xcolor}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}

\usepackage{indentfirst}
\setlength{\parindent}{2em} % Make two letter space in the first paragraph
\usepackage{setspace}
\linespread{1.5} % Line spacing setting
\usepackage{siunitx}
\setlength{\parskip}{0.5em} % Paragraph spacing setting

% \usepackage[contents =22920202204622, scale = 10, color = black, angle = 50, opacity = .10]{background}

\renewcommand{\figurename}{图}
\renewcommand{\lstlistingname}{代码} 
\renewcommand{\tablename}{表格}
\renewcommand{\contentsname}{目录}
\floatname{algorithm}{算法}

\graphicspath{ {images/} }

%%%%%%%%%%%%%
\newcommand{\StudentNumber}{22920202204622}  % Fill your student number here
\newcommand{\StudentName}{熊恪峥}  % Replace your name here
\newcommand{\PaperTitle}{作业（九）}  % Change your paper title here
\newcommand{\PaperType}{算法设计与分析} % Replace the type of your report here
\newcommand{\Date}{2022年5月8日}
\newcommand{\College}{信息学院}
\newcommand{\CourseName}{算法设计与分析}
%%%%%%%%%%%%%

%% Page header and footer setting
\usepackage{fancyhdr}
\usepackage{lastpage}
\pagestyle{fancy}
\fancyhf{}
% This requires the document to be twoside
\fancyhead[LO]{\texttt{\StudentName }}
\fancyhead[LE]{\texttt{\StudentNumber}}
\fancyhead[C]{\texttt{\PaperTitle }}
\fancyhead[R]{\texttt{第{\thepage}页，共\pageref*{LastPage}页}}


\title{\PaperTitle}
\author{\StudentName}
\date{\Date}

\lstset{
	basicstyle          =   \sffamily,          % 基本代码风格
	keywordstyle        =   \bfseries,          % 关键字风格
	commentstyle        =   \rmfamily\itshape,  % 注释的风格，斜体
	stringstyle         =   \ttfamily,  % 字符串风格
	flexiblecolumns,                % 别问为什么，加上这个
	numbers             =   left,   % 行号的位置在左边
	showspaces          =   false,  % 是否显示空格，显示了有点乱，所以不现实了
	numberstyle         =   \zihao{-5}\ttfamily,    % 行号的样式，小五号，tt等宽字体
	showstringspaces    =   false,
	captionpos          =   t,      % 这段代码的名字所呈现的位置，t指的是top上面
	frame               =   lrtb,   % 显示边框
}

\lstdefinestyle{PythonStyle}{
	language        =   Python, % 语言选Python
	basicstyle      =   \zihao{-5}\ttfamily,
	numberstyle     =   \zihao{-5}\ttfamily,
	keywordstyle    =   \color{blue},
	keywordstyle    =   [2] \color{teal},
	stringstyle     =   \color{magenta},
	commentstyle    =   \color{red}\ttfamily,
	breaklines      =   true,   % 自动换行，建议不要写太长的行
	columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加
	basewidth       =   0.5em,
}

\lstdefinestyle{CppStyle}{
	language        =   c++,
	basicstyle      =   \zihao{-5}\ttfamily,
	numberstyle     =   \zihao{-5}\ttfamily,
	keywordstyle    =   \color{blue},
	keywordstyle    =   [2] \color{teal},
	stringstyle     =   \color{magenta},
	commentstyle    =   \color{red}\ttfamily,
	breaklines      =   true,   % 自动换行，建议不要写太长的行
	columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加
	basewidth       =   0.5em,
}

\algnewcommand\algorithmicinput{\textbf{Input:}}
\algnewcommand\algorithmicoutput{\textbf{Output:}}
\algnewcommand\Input{\item[\algorithmicinput]}%
\algnewcommand\Output{\item[\algorithmicoutput]}%

\usetikzlibrary{positioning, shapes.geometric}

\begin{document}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter % change default title style
\renewcommand*\maketitle{%
	\begin{center} 
		\bfseries  % title 
		{\LARGE \@title \par}  % LARGE typesetting
		\vskip 1em  %  margin 1em
		{\global\let\author\@empty}  % no author information
		{\global\let\date\@empty}  % no date
		\thispagestyle{empty}   %  empty page style
	\end{center}%
	\setcounter{footnote}{0}%
}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	
\thispagestyle{empty}

\vspace*{1cm}

\begin{figure}[h]
	\centering
	\includegraphics[width=4.0cm]{logo.png}
\end{figure}

\vspace*{1cm}

\begin{center}
	\Huge{\textbf{\PaperType}}
	
	\Large{\PaperTitle}
\end{center}

\vspace*{1cm}

\begin{table}[h]
	\centering	
	\begin{Large}
		\renewcommand{\arraystretch}{1.5}
		\begin{tabular}{p{3cm} p{5cm}<{\centering}}
			姓\qquad 名 & \StudentName  \\
			\hline
			学\qquad号 & \StudentNumber \\
			\hline
			日\qquad期 & \Date  \\
			\hline
			学\qquad院 & \College  \\
			\hline
			课程名称 & \CourseName  \\
			\hline
		\end{tabular}
	\end{Large}
\end{table}

\newpage

\title{
	\Large{\textcolor{black}{\PaperTitle}}
}
	
	
\maketitle
	
\tableofcontents
 
\newpage
\setcounter{page}{1}

\begin{spacing}{1.2}

\section{题12.2}
\label{sec:t12.2}

对棋盘建立一个坐标系，则两个皇后在一个对角线上当且仅当$k_{ij}=1$或$k_{ij}=-1$。即

\begin{align*}
	k_{ij}=\frac{x_i-x_j}{i-j}&=1 \\
	\Rightarrow x_i-x_j&=i-j \\
\end{align*}

同理可得$x_i-x_j=j-i$

\section{题12.3}

递归地对第$1,2,\ldots,8$行枚举放的位置，放棋子时检查
同一行、同一列、对角线上是否有棋子。对角线按第\ref{sec:t12.2}节的结论进行检查
得到算法~\ref{algo:8queen}。


\begin{algorithm}[htbp]
	\caption{8皇后问题}
	\label{algo:8queen}
	\begin{algorithmic}[1]
		\Procedure{PutQuene}{$k$}
			\If{$k=8$}
				\State \Call{Print}{$pos$}
			\EndIf
			\For{$i=1\to 8$}
				\If{\Call{Check}{$k,i$}}
					\State $pos[k]\gets i$
					\State $t=$ \Call{PutQuene}{$k+1$}
					\State $pos[k]\gets 0$
				\EndIf
			\EndFor
			\State \Return $t$
		\EndProcedure

		\Procedure{Check}{$row,col$}
			\State $r=pos[row]==0$	
			\State $c=True$
			\For{$i=1\to 8$}
				\If{$pos[i]==col$}
					\State $c=False$
					\State $\mathbf{break}$
				\EndIf
			\EndFor	

			\State $d=True$
			\For{$i=1\to 8$}
				\For{$j=1\to 8$}
					\If{$row-i==col-j \ \mathbf{or} \ row-i=j-col $}
						\If{$pos[i]==j$}
							\State $d=False$
							\State $\mathbf{break}$
						\EndIf
					\EndIf
				\EndFor
			\EndFor

			\State \Return $c \ \mathbf{and} \ r \ \mathbf{and} \ d$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}	

\section{题12.4}

递归地检查所有棋子，然后标记所有能攻击的位置。最后检查是否所有的位置都被标记过了。
如算法~\ref{algo:attack}
\begin{algorithm}[htbp]
	\caption{检查能否攻击}
	\label{algo:attack}
	\begin{algorithmic}[1]
		\Procedure{Check}{$pos,n$}
			\State $board[][]=\emptyset$
			\State \Call{Mark}{$board,pos,0,n$}
			\For{$i=1\to n$}
				\For{$j=1\to n$}
					\If{$board[i][j]==0$}
						\State \Return $False$
					\EndIf
				\EndFor
			\EndFor
			\State \Return $True$
		\EndProcedure

		\Procedure{Mark}{$board,pos,k,n$}
			\State $r=pos[row]==0$	
			\State $c=True$
			\For{$i=1\to 8$}
				\If{$pos[i]==col$}
					\State $c=False$
					\State $\mathbf{break}$
				\EndIf
			\EndFor	

			\State $d=True$
			\For{$i=1\to 8$}
				\For{$j=1\to 8$}
					\If{$row-i==col-j \ \mathbf{or} \ row-i=j-col $}
						\If{$pos[i]==j$}
							\State $d=False$
							\State $\mathbf{break}$
						\EndIf
					\EndIf
				\EndFor
			\EndFor

			\State \Return $c \ \mathbf{and} \ r \ \mathbf{and} \ d$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}	

\section{题12.5}

枚举每个位置的放置方法，如算法~\ref{algo:permu}。

\begin{algorithm}[htbp]
	\caption{检查能否攻击}
	\label{algo:permu}
	\begin{algorithmic}[1]
		\Procedure{Permu}{$p,k,n$}
			\If{$k==n$}
				\State \Call{Print}{$p$}
			\EndIf
			\For{$i=1\to n$}
				\If{$vis[i]!=True$}
					\State $vis[i]=True$
					\State $p[k]=i$
					\State \Call{Permu}{$p,k+1,n$}
					\State $vis[i]=False$
				\EndIf
			\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}	

\section{题12.8}

可以在枚举每种顶点序列，并且每一步以$w[x[i-1],x[j]]\ne \infty$为约束
选择是否下一步走顶点$j$。如算法\ref{algo:hmt}


\begin{algorithm}[htbp]
	\caption{哈密顿回路}
	\label{algo:hmt}
	\begin{algorithmic}[1]
		\Procedure{Hamiton}{$w,x,k$}
			\If{$k==n$}
				\If{$w[x[n],x[1]]\ne \infty$ and $w[x[n-1],x[n]]\ne \infty$}
					\State \Call{Print}{$x$}
				\EndIf
			\EndIf
			\For{$i=k\to n-1$}
				\If{$w[x[k-1],x[j]]\ne \infty$}
					\State $x[k]\leftrightarrow x[j]$
					\State \Call{Hamiton}{$w,x,k+1$}
					\State $x[k]\leftrightarrow x[j]$
				\EndIf
			\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}	

\section{题13.2}

设计限界函数$B(i)$是当前耗时的值加上之后步骤中空闲工人中耗时最小的耗时的和。
设
$v[i]=\begin{cases}
	\infty \ \ \mbox{工人已被分配} \\
	1 \ \ \mbox{工人未被分配}
\end{cases}$
则$B(i)$如\eqref{eqn:bassign}


\begin{equation}
	\label{eqn:bassign}
	B(i)=C(i)+\sum_{j=i}^{n}\mathop{min}_k{\{c[k,j]\cdot v[k]\}}
\end{equation}

可以实现如代码~\ref{code:assign}。

\begin{lstlisting}[language=Python,numbers=left,style=PythonStyle,caption=工人分配问题,label={code:assign}]
from queue import PriorityQueue

c = [[3, 5, 2, 4], [6, 7, 5, 3], [3, 7, 4, 5], [8, 5, 4, 6]]


def get_min():
    mins = []
    for i in range(0, 4):
        minval = 0x7fffffff
        for j in range(0, 4):
            minval = min([minval, c[j][i]])
        mins.append(minval)
    return mins


def assign():
    mins = get_min()

    def b():
        ret = cur
        for i in range(step, 4):
            if not vis[i]:
                ret += mins[i]
        return ret

    ans = 0x7fffffff
    cur, step, vis = 0, 0, [False for _ in range(0, 4)]
    q = PriorityQueue()
    while step < 4:
        for i in range(0, 4):
            new_cost = cur + c[i][step]

            if vis[i] or new_cost > ans:
                continue

            if step >= 3:
                ans = min([ans, new_cost])

            vis[i] = True
            q.put([b(), (new_cost, step + 1, vis)])
            vis[i] = False

        _, (cur, step, vis) = q.get()
    return ans
\end{lstlisting}

运行结果是13。

\section{题13.4}

N皇后问题的限制函数与回溯法相同，实现如代码~\ref{code:nqueen}。

\begin{lstlisting}[language=Python,numbers=left,style=PythonStyle,caption=N皇后问题,label={code:nqueen}]
from queue import Queue


def check(pos, k, i):
    if pos[k] >= 0:
        return False

    for j in range(0, k):
        if pos[j] == i:
            return False

        if i - pos[j] == j - k:
            return False

        if i - pos[j] == k - j:
            return False

    return True


def n_queen(n):
    k, pos = 0, [-1 for i in range(0, n)]
    ans = 0
    q = Queue()
    q.put((k, pos))
    while not q.empty():
        k, pos = q.get()
        if k == n:
            print(pos)
            ans += 1
            continue

        for i in range(0, n):
            if check(pos, k, i):
                q.put((k + 1, [i if r == k else pos[r] for r in range(0, n)]))
    return ans
\end{lstlisting}

对于$N=8$的情形，该算法输出92。

\section{题13.10}

约束函数是马只能走到8个位置之一，并且该位置不越界。实现如代码~\ref{code:horse}。

\begin{lstlisting}[language=Python,numbers=left,style=PythonStyle,caption=跳马问题,label={code:horse}]

from queue import Queue

dx = [-1, -1, -2, -2, 1, 1, 2, 2]
dy = [2, -2, 1, -1, 2, -2, 1, -1]


def horse(n, sx, sy, ex, ey):
    vis = [[False for i in range(0, n)] for j in range(0, n)]
    vis[sx][sy] = True

    def check(x, y, dx, dy):
        if vis[x + dx][y + dy]:
            return False

        if x + dx < 0 or x + dx >= n:
            return False

        if y + dy < 0 or y + dy >= n:
            return False

        return True

    q = Queue()
    t = 0
    q.put((t, sx, sy))
    while not q.empty():
        t, x, y = q.get()
        if x == ex and y == ey:
            return t

        for nx, ny in zip(dx, dy):
            if check(x, y, nx, ny):
                q.put((t + 1, x + nx, y + ny))
                vis[x + nx][y + ny] = True

    return -1
\end{lstlisting}

对从$(1,1)$到$(2,1)$的情形，该算法输出4；从$(1,5)$到$(5,1)$的情形，该算法输出5。

\end{spacing}

\end{document}