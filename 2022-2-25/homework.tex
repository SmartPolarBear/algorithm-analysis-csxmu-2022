\documentclass[a4paper,twoside]{article}
\usepackage{blindtext}  
\usepackage{geometry}

% Chinese support
\usepackage[UTF8, scheme = plain]{ctex}

% Page margin layout
\geometry{left=2.3cm,right=2cm,top=2.5cm,bottom=2.0cm}


\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{float}
\usepackage{hyperref}

\usepackage{graphics}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{epsfig}
\usepackage{float}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{longtable}
\usepackage{listings}

% cite package, to clean up citations in the main text. Do not remove.
\usepackage{cite}

\usepackage{color,xcolor}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}

\usepackage{indentfirst}
\setlength{\parindent}{2em} % Make two letter space in the first paragraph
\usepackage{setspace}
\linespread{1.5} % Line spacing setting
\usepackage{siunitx}
\setlength{\parskip}{0.5em} % Paragraph spacing setting

\renewcommand{\figurename}{图}
\renewcommand{\lstlistingname}{代码} 
\renewcommand{\tablename}{表格}
\renewcommand{\contentsname}{目录}

\graphicspath{ {images/} }

%%%%%%%%%%%%%
\newcommand{\StudentNumber}{22920202204622}  % Fill your student number here
\newcommand{\StudentName}{熊恪峥}  % Replace your name here
\newcommand{\PaperTitle}{作业（一）}  % Change your paper title here
\newcommand{\PaperType}{算法设计与分析} % Replace the type of your report here
\newcommand{\Date}{2022年2月24日}
\newcommand{\College}{信息学院}
\newcommand{\CourseName}{算法设计与分析}
%%%%%%%%%%%%%

%% Page header and footer setting
\usepackage{fancyhdr}
\usepackage{lastpage}
\pagestyle{fancy}
\fancyhf{}
% This requires the document to be twoside
\fancyhead[LO]{\texttt{\StudentName }}
\fancyhead[LE]{\texttt{\StudentNumber}}
\fancyhead[C]{\texttt{\PaperTitle }}
\fancyhead[R]{\texttt{第{\thepage}页，共\pageref*{LastPage}页}}


\title{\PaperTitle}
\author{\StudentName}
\date{\Date}

\begin{document}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter % change default title style
\renewcommand*\maketitle{%
	\begin{center} 
		\bfseries  % title 
		{\LARGE \@title \par}  % LARGE typesetting
		\vskip 1em  %  margin 1em
		{\global\let\author\@empty}  % no author information
		{\global\let\date\@empty}  % no date
		\thispagestyle{empty}   %  empty page style
	\end{center}%
	\setcounter{footnote}{0}%
}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	
\thispagestyle{empty}

\vspace*{1cm}

\begin{figure}[h]
	\centering
	\includegraphics[width=4.0cm]{logo.png}
\end{figure}

\vspace*{1cm}

\begin{center}
	\Huge{\textbf{\PaperType}}
	
	\Large{\PaperTitle}
\end{center}

\vspace*{1cm}

\begin{table}[h]
	\centering	
	\begin{Large}
		\renewcommand{\arraystretch}{1.5}
		\begin{tabular}{p{3cm} p{5cm}<{\centering}}
			姓\qquad 名 & \StudentName  \\
			\hline
			学\qquad号 & \StudentNumber \\
			\hline
			日\qquad期 & \Date  \\
			\hline
			学\qquad院 & \College  \\
			\hline
			课程名称 & \CourseName  \\
			\hline
		\end{tabular}
	\end{Large}
\end{table}

\newpage

\title{
	\Large{\textcolor{black}{\PaperTitle}}
}
	
	
\maketitle
	
\tableofcontents
 
\newpage
\begin{spacing}{1.2}
%%%%%%%%%%%%%%%%%

\section{题1.2}

该算法符合算法的特点。

\begin{enumerate}
	\item \textbf{有穷性：}又穷集合有有穷个数的子集，遍历这些子集求和并判断就有有限步。因此算法能在有穷操作内完成
	
	\item \textbf{可行性：}求出子集可以用回溯算法实现，是可行的
	
	\item \textbf{确定性：}该算法的每一步是确定的
	
	\item \textbf{输入、输出：}该算法输入一个整数集和一个数，输出所有和为该数的子集
\end{enumerate}

\section{题1.5}

$FindMax(A)$算法每一行执行的次数如表\ref{tbl:p15}

\begin{table}[h]
	\renewcommand{\arraystretch}{1.2}
	\caption{执行一行的次数}
	\label{tbl:p15}
	\begin{center}
		{\footnotesize
			\begin{tabular}{c l}
				\toprule
				{花费} & {次数} \\
				\midrule
				$c_1$ & 1 \\
				\hline
				$c_3$ & n-1 \\
				\hline
				$c_4$ & $\Sigma_{j=2}^{n}t_j$ \\
				\hline
				$c_5$ & 1 \\
				\bottomrule
		\end{tabular}}
	\end{center}
\end{table}

其中$t_j$为

$$ t_j=\left\{
\begin{aligned}
	1 & \  \mbox{当for循环的第j轮中if条件成立} \\
	0 & \  \mbox{当for循环的第j轮中if条件不成立} \\
\end{aligned}
\right.
$$

则算法运行所需要的时间为

\begin{equation}
T(n)=c_1 + c_3 \times (n-1) + c_4 \times \Sigma_{j=2}^{n}t_j + c_5 \label{eqn:tn15}
\end{equation}

当$A$中的最大值的位置在末尾时，\eqref{eqn:tn15}中$t_j$满足

$$
t_2=\dots=t_n=1
$$

此时$T(n)$最大，最大值为

\begin{align*}
T(n) & =c_1 + c_3 \times (n-1) + c_4 \times (n-2) + c_5 \\
& = c_1 - c_3 - 2 \times c_4 +c_5 + (c_3+c_4) \times n  
\end{align*}

则$FindMax(A)$的时间复杂度为
$$
O(n)
$$

\section{题1.6}

$FindMax(A)$有循环不变量$L_j$

$$
L_j: \mbox{在$for$循环的第$j$个迭代执行前，$max$中有A[$1 \dots j-1$]中的最大值}
$$

\textbf{初始步：} 在循环开始前$j=2$，$max=A[1]$是$A[1 \dots 1]$中的最大值，$L_2$为真；

\textbf{归纳步：} 如果在循环的第$k$个迭代前$L_{k}$为真，则max有$A[1 \dots k-1]$中的最大值，当执行迭代$k$时，若$A[k] > max$则令$max=A[k]$。此时$max$有$A[1 \dots k]$中的最大值。在下一迭代开始前，$L_k$为真；

\textbf{终止步：} 此时$j=n+1$，由第二步的保证，则$max$有$A[1 \dots n]$中的最大值。
对于任意输入$A$，此$FindMax(A)$都有一个正确的输出。因此$FindMax(A)$是正确的。

\section{题1.7}
该算法从头遍历集合，记录到当前位置为止最大数字的下标。算法如下
\begin{algorithm}
	\caption{查找最大值，返回下标}
	\begin{algorithmic}[1]
		\Procedure{FindMax}{$A$}     
		\State $max \gets 1$
		\For{$j \gets 2$  to $n$}
		\If{$A[j]>A[max]$}
		\State $max \gets j$
		\EndIf
		\EndFor
		\Return max
		\EndProcedure
		
	\end{algorithmic}
\end{algorithm}

\section{题1.8}

$Exp(a,n)$有循环不变式$L_i$

$$
L_i: \mbox{在$while$循环的第$i$个迭代执行前，$pow$中有$a^{i-1}$}
$$

\textbf{初始步：}在循环开始前$i=1$，$pow=1=a^0=a^{i-1}$，$L_i$为真；

\textbf{归纳步：}如果在循环的第$k$个迭代前$L_{k}$为真，则$pow=a^{k-1}$，当执行迭代$k时$令$pow \gets pow \times a$，此时$pow=a^{k}$。在下一迭代开始前，$L_k$为真；

\textbf{终止步：}此时$i=n+1$，由第二步的保证，则$pow=a^{n}$
对于任意输入$(a,n)$，此$Exp(a,n)$都有一个正确的输出。因此$Exp(a,n)$是正确的。
\section{题1.9}

\subsection{算法}

\begin{algorithm}
	\caption{查找指定定值x，返回下标}
	\begin{algorithmic}[1]
		\Procedure{Find}{$A,x$}     
		\State $idx \gets 0$
		
		\For{$j \gets 1$  to $n$}
		\If{$A[j]==x$}
		\State $idx \gets j$
		\State break
		\EndIf
		\EndFor
		
		\Return idx
		\EndProcedure
		
	\end{algorithmic}
\end{algorithm}

该算法循环判断每一个元素是否等于$x$，在没找到$x$时返回0。

\subsection{正确性}

$Find(A,x)$有循环不变量$L_j$

$$
L_j: \mbox{在$for$循环的第$j$个迭代执行前，$idx$中有$A[1 \dots j-1]$中等于$x$的下标}
$$

\textbf{初始步：} 在循环开始前$j=1$，$max=A[1]$是$A[1 \dots 0]$中等于$x$的下标，$L_1$为真；

\textbf{归纳步：} 如果在循环的第$k$个迭代前$L_{k}$为真，则max有$A[1 \dots k-1]$中等于$x$值，当执行迭代$k$时，若$A[k] == x$则令$idx=k$。此时$max$有$A[1 \dots k]$中等于$x$值。在下一迭代开始前，$L_k$为真；

\textbf{终止步：} 此时$j=n+1$，由第二步的保证，则$max$有$A[1 \dots n]$中的中等于$x$值。
对于任意输入$A$，此$Find(A,x)$都有一个正确的输出。因此$Find(A,x)$是正确的。

\subsection{时间复杂度}
$Find(A,x)$算法每一行执行的次数如表\ref{tbl:p19}
\begin{table}[h]
	\renewcommand{\arraystretch}{1.2}
	\caption{执行每一行的次数}
	\label{tbl:p19}
	\begin{center}
		{\footnotesize
			\begin{tabular}{c l}
				\toprule
				{花费} & {次数} \\
				\midrule
				$c_1$ & 1 \\
				\hline
				$c_2$ & $t$ \\
				\hline
				$c_3$ & $t-1$ \\
				\hline
				$c_4$ & $t-1$ \\
				\hline
				$c_5$ & 1 \\
				\bottomrule
		\end{tabular}}
	\end{center}
\end{table}


则算法运行所需要的时间为

\begin{equation}
	T(n)=c_1 + c_2 \times t + c_3 \times (t-1) + c_4 \times (t-1) + c_5 \label{eqn:tn19}
\end{equation}

当$x$位于末尾时$t$最大，$t=n+1$，则

\begin{align*}
	T(n)&=c_1 + c_2 \times (n+1) + c_3 \times n + c_4 \times n  + c_5 \\
	&= (c_1+c_2+c_5)+(c_2+c_3+c_4) \times n
\end{align*}

该算法的最坏时间复杂度为$O(n)$。

\section{题1.10}

若前者比后者快，则有
$$
100n^2 \le 2^n
$$

解得

$$
n \ge 14.324727836998200633849297216651
$$

则从$n=15$前者比后者快。

\section{题1.11}
若插入排序的效率高于归并排序，则有
\begin{align*}
	8n^2 \le 64n \log n
\end{align*}

解得

\begin{align*}
	n \le 6.5070996729820298949891210615877
\end{align*}

则当$n$取$1,2,3,4,5,6$时插入排序的效率高于归并排序。

\end{spacing}
\end{document}